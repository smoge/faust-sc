declare name "scUGens";
declare author "LFSaw";
declare copyright "MIT";

import("stdfaust.lib");
import("taiUtils.lib");
lf = library("taiStudio.lib");
rnd = library("taiRand.lib");

//---------------------------------`(sc.)hasher`---------------------------------------
// hashing a value. output is a float between [0..1]
//
// this is a convenience definition equivalent to `rnd.fhash`. 
//
// #### Usage
//
// ```
// _: hasher : _;
// ```
//-----------------------------------------------------------------------------
hasher = rnd.fhash;

//---------------------------------`(sc.)impulse`---------------------------------------
// Periodic 1-sample impulse at given frequency. 
// Setting `freq == 0` and `phase == 0` 
// (i.e. infinite duration between first and subsequent impulses) 
// results in a dirac-impulse.  
//
// #### Usage
//
// ```
// impulse(freq, phase) : _;
// ```
// with
//
// * `freq`: frequency in Hz
// * `phase`: phase in the range of 0..1
// note that initial impulse for `phase % 1 == 0` only happens for `phase == 1` 
//-----------------------------------------------------------------------------
// impulse(freq) = os.lf_imptrain(freq);
impulse(freq, 0) = 1-1', (lfsaw_uni(freq, 0) : lf.strictFalling) :> _ ; 
impulse(freq, phase) = lfsaw_uni(freq, phase) : lf.strictFalling;


//---------------------------------`(sc.)lfsaw_uni`---------------------------------------
// Unipolar lfsaw in the range [0..1]
//
// #### Usage
//
// ```
// lfsaw_uni(freq, phase) : _;
// ```
// with
// 
// * `freq`: frequency
// * `phase`: phase
//-----------------------------------------------------------------------------
lfsaw_uni(freq, phase) = inc(freq) + phaseChange(phase : ma.frac) : + ~ ma.frac with {
	// `_ : ma.frac` <=> `_ : _ % 1.0`
    // only apply change of phase to incremental part
    phaseChange(phase) = phase - phase';
    inc(freq) = freq/float(ma.SR);
};


//---------------------------------`(sc.)lfsaw`---------------------------------------
// aliasing (rising) sawtooth wave in the range [-1, 1]
//
// * `freq`: frequency in Hz
// * `phase`: phase in the range of 0..1
// 
// #### Usage
//
// ```
// lfsaw(freq, phase) : _;
// ```
// with
//
// * `freq`: frequency in Hz
// * `phase`: phase in the range of 0..1
// 
// a phase of `-0.5` starts oscillator at minimal value
//-----------------------------------------------------------------------------
lfsaw(freq, phase) = lfsaw_uni(freq, phase) * 2 - 1;



//---------------------------------`(sc.)sinosc`---------------------------------------
// sinewave oscillator
// 
// #### Usage
//
// ```
// sinosc(freq, phase)
// ```
// with 
// * `freq`: frequency in Hz
// * `phase`: phase in the range of 0..2pi
//-----------------------------------------------------------------------------
sinosc(freq, phase) = os.oscp(freq, phase);

//---------------------------------`(sc.)lfpulse`---------------------------------------
// aliasing pulsewave in the range [0..1]
// #### Usage
//
// ```
// lfpulse(freq, width, phase)
// ```
// with
// * `freq`: frequency in Hz
// * `width`: pulse width duty in the range of 0..1
// * `phase`: phase in the range of 0..1
//-----------------------------------------------------------------------------
lfpulse(freq, width, phase) = float(os.lf_sawpos_phase(phase, freq) <= width);



//---------------------------------`(sc.)lftri`---------------------------------------
// aliasing triangle oscillator in the range [-1, 1]
// #### Usage
//
// ```
// lftri(freq, phase)
// ```
// with
// * `freq`: frequency in Hz
// * `phase`: phase in the range of 0..1
//
// a phase of `-0.5` starts oscillator at minimal value
//-----------------------------------------------------------------------------
lftri(freq, phase) = lfsaw(freq, phase) * 2: fold(-1, 1);


//---------------------------------`(sc.)whitenoise`---------------------------------------
// bipolar whitenoise generator 
// #### Usage
//
// ```
// whitenoise(amp) : _;
// ```
// with
// * `amp`: amplitude
//
//-----------------------------------------------------------------------------
whitenoise(amp) = no.noise * amp;



//---------------------------------`(sc.)pinknoise`---------------------------------------
// bipolar pink-noise generator 
// #### Usage
//
// ```
// pinknoise(amp) : _;
// ```
// with
// * `amp`: amplitude
//
//-----------------------------------------------------------------------------
pinknoise(amp) = no.pink_noise * amp;


//---------------------------------`(sc.)dust`---------------------------------------
// dust generator 
// #### Usage
//
// ```
// dust(density) : _;
// ```
// with
// * `density`: approximate number of values per second
//
//-----------------------------------------------------------------------------
dust(density) = no.sparse_noise(density);

//---------------------------------`(sc.)mod`---------------------------------------
// save modulo (SC style, i.e. \IR^2 \to \IR^+)
//
// #### Usage
//
// ```
// mod(a, b)
// ```
//-----------------------------------------------------------------------------
mod(a, 0) = 0;
mod(a, b) = ba.if(a > 0, a % b, a % b + b);


//---------------------------------`(sc.)size`---------------------------------------
// size of a list
//
// #### Usage
//
// ```
// size((a, b, ...)) : N
// ```
// with N being a constant at runtime
// 
//-----------------------------------------------------------------------------
size(LIST) = ba.count(LIST);


//---------------------------------`(sc.)wrapAt`---------------------------------------
// sc-style `wrapAt` for lists (starting at 0, wrapping around)
//
// #### Usage
//
// ```
// wrapAt((a, b, ...), IDX) : _
// ```
// 
// 
//-----------------------------------------------------------------------------
wrapAt(LIST, IDX) = ba.take(mod((IDX+1), size(LIST)), LIST);

//---------------------------------`(sc.)at`---------------------------------------
// sc-style `at` for lists (starting at 0, no wrapping)
//
// #### Usage
//
// ```
// at((a, b, ...), IDX) : _
// ```
// 
// 
//-----------------------------------------------------------------------------
at(LIST, IDX) = ba.take(IDX+1, LIST);




//---------------------------------`(sc.)rotate`---------------------------------------
// sc-style `rotate` for lists
//
// #### Usage
//
// ```
// rotate(list, AMOUNT) : bus(sc.size(list))
// ```
// 
// #### Example
//
// process = rotate((1, 2, 3, 4, 5, 6, 7, 8, 9, 10), 4);
//
//-----------------------------------------------------------------------------
rotate(list, 0) = list;
rotate((a, b, c), NUMBER) = rotate((c, a, b), NUMBER-1);
rotate((a, b), NUMBER) = rotate((b, a), NUMBER-1);
rotate(elem, NUMBER) = elem;


// //---------------------------------`(sc.)scramble`---------------------------------------
// // sc-style `rotate` for lists
// //
// // #### Usage
// //
// // ```
// // scramble(seed, list) : bus(sc.size(list))
// // ```
// // 
// // #### Example
// //
// // process = scramble(1245678765, (1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
// //
// //-----------------------------------------------------------------------------
// scramble(seed, (a, b, c)) = scramble(NUMBER-1, (c, a, b));
// scramble(seed, (a, b)) = scramble(NUMBER-1, (b, a));
// scramble(seed, elem) = elem;


//---------------------------------`(sc.)drop`---------------------------------------
// sc-style `drop` for lists (drop N left elements)
//
// #### Usage
//
// ```
// drop(list, N) : bus(sc.size(list)-N)
// ```
// 
// #### Example
//
// process = drop((1, 2, 3, 4, 5, 6, 7, 8, 9, 10), 4);
//
//-----------------------------------------------------------------------------
drop(list, N) = ba.subseq(list, 0, ba.count(list) - N);

// keep left elements
//---------------------------------`(sc.)keep`---------------------------------------
// sc-style `keep` for lists (keep N left elements)
//
// #### Usage
//
// ```
// keep(list, N) : bus(N)
// ```
// 
// #### Example
//
// process = keep((1, 2, 3, 4, 5, 6, 7, 8, 9, 10), 4);
//
//-----------------------------------------------------------------------------
keep(list, N) = ba.subseq(list, N, ba.count(list));

//---------------------------------`(sc.)reverse`---------------------------------------
// sc-style `reverse` for lists
//
// #### Usage
//
// ```
// reverse((x, xs))
// ```
// 
// #### Example
//
// process = reverse((1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
//
//-----------------------------------------------------------------------------
reverse(x) = par(i, length, ba.take(length - i, x)) with {
    length = ba.count(x);
};


//---------------------------------`(sc.)wrap2`---------------------------------------
// wrap signal between -hi, hi
//
// #### Usage
//
// ```
// _ : wrap2(hi) : _
// ```
//-----------------------------------------------------------------------------
wrap2(hi) = _ % hi; // note the use of faust-specific modulo (resulting in values between [-hi, hi]) here


//---------------------------------`(sc.)wrap`---------------------------------------
// wrap signal between lo and hi
//
// #### Usage
//
// ```
// _ : wrap(lo, hi) : _
// ```
//-----------------------------------------------------------------------------
wrap(0, hi) = _ - hi2 : wrap2(hi2) + (hi2) with {
    hi2 = hi/2;
};
wrap(lo, lo) = lo; // same value for lo and hi results in constant value
wrap(lo, hi) = _ - lo : wrap(0, hi - lo) + lo;



//---------------------------------`(sc.)clip2`---------------------------------------
// clip signal between -hi and hi
//
// #### Usage
//
// ```
// _ : clip2(hi) : _
// ```
//-----------------------------------------------------------------------------
clip2(hi) = _ : clip(-abs_h, abs_h) with {
    abs_h = abs(hi);
};


//---------------------------------`(sc.)clip`---------------------------------------
// clip signal between lo and hi
//
// #### Usage
//
// ```
// _ : clip(lo, hi) : _
// ```
//-----------------------------------------------------------------------------
clip(lo, hi) = _ : clip_l(lo) : clip_h(hi) with {
    clip_l(lo) = _ <: ba.if(_ < lo, lo, _);
    clip_h(hi) = _ <: ba.if(_ > hi, hi, _);
};


//---------------------------------`(sc.)fold`---------------------------------------
// fold signal between lo and hi
//
// #### Usage
//
// ```
// _ : fold(lo, hi) : _
// ```
//-----------------------------------------------------------------------------
fold(lo, hi, x) = fold_0(hi-lo, x - lo) + lo with {
    // fold between 0..range 
    fold_0(range, x) = onefold_0(range, mod(x, 2*range));

    // fold assuming input is in the range 0..range2
    onefold_0(range, x) = ba.if(x > range, range-(x-range), x);
};

//---------------------------------`(sc.)fold2`---------------------------------------
// fold signal between -hi and hi
//
// #### Usage
//
// ```
// _ : fold2(hi) : _
// ```
// 
// #### Example
//
// ```
// process = sinosc(ma.SR / 256, 0) * factor <: _/factor, fold2(0.2, _) with {
//     factor = 10;
// };
// ```
//-----------------------------------------------------------------------------
fold2(hi) = _ : fold(-hi, hi);

//---------------------------------`(sc.)trig1_1`---------------------------------------
// When a nonpositive to positive transition occurs at the input, 
// `trig1` outputs the level of the triggering input for one sample.
// If not triggered, it outputs zero.
//
// #### Usage
//
// ```
// _ : trig1_1 : _;
// ```
//-----------------------------------------------------------------------------
trig1_1(x) = lf.strictRising(x > 0);


//---------------------------------`(sc.)trig_1`---------------------------------------
// When a nonpositive to positive transition occurs at the input, 
// `trig` outputs the level of the triggering input for one sample.
// If not triggered, it outputs zero.
//
// #### Usage
//
// ```
// _ : trig_1 : _;
// ```
//-----------------------------------------------------------------------------
trig_1(x) = lf.strictRising(x > 0) * x;


//---------------------------------`(sc.)sinoscfb`---------------------------------------
// SinOscFB is a sine oscillator that has phase modulation feedback; 
// its output plugs back into the phase input. Basically this allows 
// a modulation between a sine wave and a sawtooth like wave. 
// Overmodulation causes chaotic oscillation. 
//
// #### Usage
//
// ```
// sinoscfb(freq, feedback) : _;
// ```
// with
// * `freq`: frequency in Hz
// * `phase`: phase in the range of 0..1
// * `feedback`: amplitude of phase feedback in radians.
//-----------------------------------------------------------------------------
sinoscfb(freq, feedback) = sinoscfb_p(freq, 0, feedback);

sinoscfb_p(freq, phase, feedback) = sfb(freq, phase, feedback) ~ _ with {
    sfb(freq, phase, feedback, x) = sinosc(freq, phase + feedback * x);
} ;

//---------------------------------`(sc.)pmosc`---------------------------------------
// Phase modulation sinwave oscillator pair.
//
// #### Usage
//
// ```
// pmosc(carFreq, modFreq, modAmp) : _;
// ```
// with
// 
// * `freq`: frequency in Hz
// * `width`: pulse width duty in the range of 0..1
// * `phase`: phase in the range of 0..1
//-----------------------------------------------------------------------------
pmosc(carfreq, modfreq, pmindex, modphase) = sinosc(carfreq, sinosc(modfreq, modphase) * pmindex);




//---------------------------------`(sc.)latch`---------------------------------------
// Holds input signal value when triggered (`trig` moves from negative to positive). 
// Outputs 0 until it receives its first trigger.
//
// #### Usage
//
// ```
// _ : latch(trig) : _;
// ```
// with
// 
// * `trig`: trigger signal
//-----------------------------------------------------------------------------
latch(trig) = _ : select2(trig1_1(trig), _, _) ~ _;




//---------------------------------`(sc.)gate`---------------------------------------
// Allows input signal value to pass when `trig` is positive, otherwise holds last value.
//
// #### Usage
//
// ```
// _ : gate(trig) : _;
// ```
// with
// 
// * `trig`: gating signal
//-----------------------------------------------------------------------------
gate(trig) = _ : select2(trig <= 0, _, _) ~ _;



//---------------------------------`(sc.)demand_1`---------------------------------------
// A triggered state machine.
// Its input acts as a trigger, it outputs the current state of the internal function.
//
// #### Usage
//
// ```
// _ : demand_1(f) : _;
// ```
// with
// 
// * `f`: 	function called to determine next state, 
// 			initial state input is `0`, all subsequent states are 
// 			the output of previous call of `f`
//-----------------------------------------------------------------------------
demand_1(f, tr) = f ~ par(i, outputs(f), latch(tr));



//---------------------------------`(sc.)tdemand_1`---------------------------------------
// A triggered state machine.
// Its input acts as a trigger. If triggered, it outputs the current state of the internal function, otherwise 0.
//
// #### Usage
//
// ```
// _ : tdemand_1(f) : _;
// ```
// with
// 
// * `f`: 	function called to determine next state, 
// 			initial state input is `0`, all subsequent states are 
// 			the output of previous call of `f`
//-----------------------------------------------------------------------------
tdemand_1(f, tr) = demand_1(f, tr) : par(i, outputs(f), select2(tr, 0, _));


//---------------------------------`(sc.)lpf`---------------------------------------
// 2-nd order butterworth filter
//
// #### Usage
//
// ```
// _ : tdemand_1(f) : _;
// ```
// with
// 
// * `f`: 	function called to determine next state, 
// 			initial state input is `0`, all subsequent states are 
// 			the output of previous call of `f`
//-----------------------------------------------------------------------------
lpf(freq) = fi.lowpass(2, freq);


//---------------------------------`(sc.)linlin`---------------------------------------
// linear remapping
//
// #### Usage
//
// ```
// _ : minmin(0, 1, 4, 10) : _
// ```
//-----------------------------------------------------------------------------
linlin(in_min, in_max, out_min, out_max) = _ : normalise(in_min, in_max) : expand(out_min, out_max) 
with{
    normalise(r_min, r_max) = _ - r_min :  _ / (r_max - r_min);
    expand(r_min, r_max) = _ * (r_max - r_min) : _ + rmin;
};
